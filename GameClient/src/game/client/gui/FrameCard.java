/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package game.client.gui;

import game.client.common.CommonDefine;
import game.client.common.CommonMethod;
import game.client.element.Card;
import game.client.element.CardType;
import game.client.element.Player;
import game.client.image.ImageInit;
import game.client.func.CardFunc;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author tkv-nhukhanhdinh
 */
public class FrameCard extends javax.swing.JFrame {

    private boolean start;
    private boolean start_enable;
    private boolean enableTurn;
    private boolean host;
    private int betCoin;
    private Map<String, Image> listImageCard;
    private Graphics mainGraphics;

    /**
     * Creates new form NewJFrame
     *
     * @param listImage
     */
    public FrameCard(Map<String, Image> listImage) {
        if (listImage == null) {
            listImage = ImageInit.initCardImage();
        }
        this.listImageCard = listImage;
        initComponents();
        CommonMethod.setLocationFrame(this);
    }

    public int getBetCoin() {
        return betCoin;
    }

    public void setBetCoin(int betCoin) {
        this.betCoin = betCoin;
        tf_betcoin.setText(String.valueOf(this.betCoin));
    }

    public boolean isStart() {
        return start;
    }

    public void setStart(boolean start) {
        this.start = start;
        if (start) {
            btn_submit.setEnabled(false);
            tf_betcoin.setEditable(false);
            clearRound();
        } else if (host) {
            btn_submit.setEnabled(true);
            tf_betcoin.setEditable(true);
        }
    }

    public boolean isStartEnable() {
        return start_enable;
    }

    public void setStartEnable(boolean play_enable) {
        if (!host) {
            return;
        }
        this.start_enable = play_enable;
        if (this.start_enable) {
            drawPlayButton(getGraphicsMain(), false);
        }
    }

    public boolean isEnableTurn() {
        return enableTurn;
    }

    public void setEnableTurn(boolean enableTurn) {
        this.enableTurn = enableTurn;
        if (!enableTurn) {
            main_panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            clearTimeCounDown();
        }
        if (start) {
            drawPassButton(getGraphicsMain(), false);
            drawFightButton(getGraphicsMain(), false);
        }
    }

    public boolean isHost() {
        return host;
    }

    public void setHost(boolean host) {
        this.host = host;
        if (!this.host) {
            Player p = getPlayerByValue(myValue);
            if (p != null) {
                drawOwnInfomation(p);
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        top_panel = new javax.swing.JPanel();
        ctop_1 = new javax.swing.JPanel();
        ctop_2 = new javax.swing.JPanel();
        ctop_3 = new javax.swing.JPanel();
        ctop_4 = new javax.swing.JPanel();
        left_panel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        tf_mess = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        chat_box = new javax.swing.JTextArea();
        jPanel2 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        pn_avatar = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        lb_name = new javax.swing.JLabel();
        lb_coin = new javax.swing.JLabel();
        jPanel6 = new javax.swing.JPanel();
        lb_bet = new javax.swing.JLabel();
        tf_betcoin = new javax.swing.JTextField();
        btn_submit = new javax.swing.JButton();
        main_panel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        top_panel.setBackground(new java.awt.Color(204, 204, 204));

        javax.swing.GroupLayout ctop_1Layout = new javax.swing.GroupLayout(ctop_1);
        ctop_1.setLayout(ctop_1Layout);
        ctop_1Layout.setHorizontalGroup(
            ctop_1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 250, Short.MAX_VALUE)
        );
        ctop_1Layout.setVerticalGroup(
            ctop_1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 40, Short.MAX_VALUE)
        );

        top_panel.add(ctop_1);

        javax.swing.GroupLayout ctop_2Layout = new javax.swing.GroupLayout(ctop_2);
        ctop_2.setLayout(ctop_2Layout);
        ctop_2Layout.setHorizontalGroup(
            ctop_2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 250, Short.MAX_VALUE)
        );
        ctop_2Layout.setVerticalGroup(
            ctop_2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 40, Short.MAX_VALUE)
        );

        top_panel.add(ctop_2);

        javax.swing.GroupLayout ctop_3Layout = new javax.swing.GroupLayout(ctop_3);
        ctop_3.setLayout(ctop_3Layout);
        ctop_3Layout.setHorizontalGroup(
            ctop_3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 250, Short.MAX_VALUE)
        );
        ctop_3Layout.setVerticalGroup(
            ctop_3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 40, Short.MAX_VALUE)
        );

        top_panel.add(ctop_3);

        javax.swing.GroupLayout ctop_4Layout = new javax.swing.GroupLayout(ctop_4);
        ctop_4.setLayout(ctop_4Layout);
        ctop_4Layout.setHorizontalGroup(
            ctop_4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 250, Short.MAX_VALUE)
        );
        ctop_4Layout.setVerticalGroup(
            ctop_4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 40, Short.MAX_VALUE)
        );

        top_panel.add(ctop_4);

        getContentPane().add(top_panel, java.awt.BorderLayout.PAGE_START);

        left_panel.setMaximumSize(new java.awt.Dimension(250, 600));
        left_panel.setMinimumSize(new java.awt.Dimension(250, 600));

        jPanel1.setBackground(new java.awt.Color(51, 51, 51));

        tf_mess.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                tf_messKeyPressed(evt);
            }
        });

        chat_box.setEditable(false);
        chat_box.setColumns(20);
        chat_box.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        chat_box.setLineWrap(true);
        chat_box.setRows(5);
        chat_box.setWrapStyleWord(true);
        jScrollPane1.setViewportView(chat_box);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tf_mess)
            .addComponent(jScrollPane1)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 330, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(tf_mess, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        jPanel2.setBackground(new java.awt.Color(204, 204, 204));

        pn_avatar.setBackground(new java.awt.Color(102, 102, 102));
        pn_avatar.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                pn_avatarMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout pn_avatarLayout = new javax.swing.GroupLayout(pn_avatar);
        pn_avatar.setLayout(pn_avatarLayout);
        pn_avatarLayout.setHorizontalGroup(
            pn_avatarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
        );
        pn_avatarLayout.setVerticalGroup(
            pn_avatarLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        jPanel5.setBackground(new java.awt.Color(204, 204, 204));

        lb_name.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        lb_name.setText("Username:username");

        lb_coin.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        lb_coin.setText("Coin:123456");

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(lb_name, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(lb_coin, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(lb_name)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(lb_coin)
                .addContainerGap(21, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pn_avatar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pn_avatar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        lb_bet.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        lb_bet.setText("Bet");

        tf_betcoin.setEditable(false);
        tf_betcoin.setBackground(new java.awt.Color(51, 51, 51));
        tf_betcoin.setForeground(new java.awt.Color(0, 255, 255));
        tf_betcoin.setText("0");
        tf_betcoin.setToolTipText("");
        tf_betcoin.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                tf_betcoinMouseClicked(evt);
            }
        });

        btn_submit.setText("Submit");
        btn_submit.setEnabled(false);
        btn_submit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_submitActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lb_bet, javax.swing.GroupLayout.PREFERRED_SIZE, 61, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(tf_betcoin, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btn_submit, javax.swing.GroupLayout.DEFAULT_SIZE, 83, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addGap(0, 0, 0)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lb_bet)
                    .addComponent(tf_betcoin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btn_submit))
                .addGap(0, 0, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel6, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 102, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout left_panelLayout = new javax.swing.GroupLayout(left_panel);
        left_panel.setLayout(left_panelLayout);
        left_panelLayout.setHorizontalGroup(
            left_panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        left_panelLayout.setVerticalGroup(
            left_panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, left_panelLayout.createSequentialGroup()
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        getContentPane().add(left_panel, java.awt.BorderLayout.LINE_START);

        main_panel.setBackground(new java.awt.Color(102, 102, 102));
        main_panel.setForeground(new java.awt.Color(102, 102, 102));
        main_panel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                main_panelMouseMoved(evt);
            }
        });
        main_panel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                main_panelMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                main_panelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                main_panelMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout main_panelLayout = new javax.swing.GroupLayout(main_panel);
        main_panel.setLayout(main_panelLayout);
        main_panelLayout.setHorizontalGroup(
            main_panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 900, Short.MAX_VALUE)
        );
        main_panelLayout.setVerticalGroup(
            main_panelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 600, Short.MAX_VALUE)
        );

        getContentPane().add(main_panel, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void test() {
        if (true) {
            new Thread(() -> {
                try {
                    Thread.sleep(1000);
                    initTEST();
                    setEnableTurn(true);
                    setStart(true);
                    drawPlayButton(getGraphicsMain(), false);
                    drawFightButton(getGraphicsMain(), false);
                    drawPassButton(getGraphicsMain(), false);
                    drawCountDownImg(9, 15, true);
                    stealWinVal = 7;
                    updatePlayer(1, null, 2000, 0);
                    //updatePlayer(2, null, -1000, 0);
                    updatePlayer(3, null, -1000, 0);
                    updatePlayer(4, null, -1000, 0);
                } catch (InterruptedException ex) {
                    Logger.getLogger(FrameCard.class.getName()).log(Level.SEVERE, null, ex);
                }
            }).start();
        }
    }

    private void btn_submitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_submitActionPerformed
        String bc = tf_betcoin.getText();
        if (bc == null || !CommonMethod.isValidNumber(bc)) {
            tf_betcoin.setText(String.valueOf(getBetCoin()));
        } else {
            if (Integer.parseInt(bc.trim()) > 10000) {
                bc = "10000";
            }
            ClientFrame.getClientFrame().sendMessage(CommonDefine.CARD_GAME_BETTING_COIN + bc.trim());
        }
        tf_betcoin.setEditable(false);
        btn_submit.setEnabled(false);
    }//GEN-LAST:event_btn_submitActionPerformed

    private void tf_betcoinMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_tf_betcoinMouseClicked
        if (start) {
            return;
        }
        if (evt.getClickCount() == 2) {
            if (host) {
                tf_betcoin.setEditable(true);
                btn_submit.setEnabled(true);
            }
        }
    }//GEN-LAST:event_tf_betcoinMouseClicked

    private void tf_messKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_tf_messKeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER) {
            String mess = tf_mess.getText();
            if (mess != null && mess.trim().length() > 0) {
                if (!mess.contains(" ")) {
                    int w = chat_box.getGraphics().getFontMetrics().stringWidth(mess);
                    if (w > 175) {
                        return;
                    }
                }
                ClientFrame.getClientFrame().sendMessage(CommonDefine.CARD_GAME_SEND_MESS + mess);
                tf_mess.setText("");
                tf_mess.requestFocus();
            }
        }
    }//GEN-LAST:event_tf_messKeyPressed

    private void main_panelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_main_panelMouseClicked
        int x = evt.getX();
        int y = evt.getY();
        switch (getGameType()) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                if (start_enable && !start) {
                    if (host && isPlayGameHover(x, y)) {
                        ClientFrame.getClientFrame().sendMessage(CommonDefine.CARD_GAME_START_GAME);
                        main_panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                        setStartEnable(false);
                    }
                }
                if (start) {
                    if (isListCardHover(x, y)) {
                        selectCard(x, y);
                    } else if (enableTurn && isButtonFightHover(x, y)) {
                        setEnableTurn(!onClickFight());
                    } else if (enableTurn && isButtonPassHover(x, y)) {
                        setEnableTurn(!onClickPass());
                    }
                }
                break;
            case CommonDefine.GAME_TYPE_SL_GAME:

                break;
            default:
                break;
        }
    }//GEN-LAST:event_main_panelMouseClicked
    private boolean isHoverFight = false;
    private boolean isHoverPass = false;
    private boolean isHoverPlay = false;
    private void main_panelMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_main_panelMouseMoved
        int x = evt.getX();
        int y = evt.getY();
        switch (getGameType()) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                if (start && enableTurn) {
                    if (isButtonFightHover(x, y)) {
                        if (!isHoverFight) {
                            isHoverFight = true;
                            drawFightButton(getGraphicsMain(), isHoverFight);
                            main_panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
                        }
                    } else {
                        if (isHoverFight) {
                            isHoverFight = false;
                            drawFightButton(getGraphicsMain(), isHoverFight);
                            main_panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                        }
                    }
                    if (isButtonPassHover(x, y)) {
                        if (!isHoverPass) {
                            isHoverPass = true;
                            drawPassButton(getGraphicsMain(), isHoverPass);
                            main_panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
                        }
                    } else {
                        if (isHoverPass) {
                            isHoverPass = false;
                            drawPassButton(getGraphicsMain(), isHoverPass);
                            main_panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                        }
                    }
                }
                if (start_enable && !start && host) {
                    if (isPlayGameHover(x, y)) {
                        if (!isHoverPlay) {
                            isHoverPlay = true;
                            drawPlayButton(getGraphicsMain(), isHoverPlay);
                            main_panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
                        }
                    } else {
                        if (isHoverPlay) {
                            isHoverPlay = false;
                            drawPlayButton(getGraphicsMain(), isHoverPlay);
                            main_panel.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
                        }
                    }
                }
                break;
            case CommonDefine.GAME_TYPE_SL_GAME:

                break;
            default:
                break;
        }
    }//GEN-LAST:event_main_panelMouseMoved

    private void main_panelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_main_panelMousePressed
        int x = evt.getX();
        int y = evt.getY();
        switch (getGameType()) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                if (start_enable && !start && host) {
                    if (isPlayGameHover(x, y)) {
                        drawPlayButtonPress(getGraphicsMain());
                    }
                }
                break;
            case CommonDefine.GAME_TYPE_SL_GAME:

                break;
            default:
                break;
        }
    }//GEN-LAST:event_main_panelMousePressed

    private void main_panelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_main_panelMouseReleased
        int x = evt.getX();
        int y = evt.getY();
        switch (getGameType()) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                if (start_enable && !start && host) {
                    if (isPlayGameHover(x, y)) {
                        drawPlayButton(getGraphicsMain(), true);
                    } else {
                        drawPlayButton(getGraphicsMain(), false);
                    }
                }
                break;
            case CommonDefine.GAME_TYPE_SL_GAME:

                break;
            default:
                break;
        }
    }//GEN-LAST:event_main_panelMouseReleased

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        this.dispose();
        ClientFrame.getClientFrame().setVisible(true);
        if(isStart()){
            ClientFrame.getClientFrame().addCoin(-5 * betCoin);
        }
        ClientFrame.getClientFrame().sendMessage(CommonDefine.NOTICE_CLIENT_OUT_GAME);
    }//GEN-LAST:event_formWindowClosing

    private void pn_avatarMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pn_avatarMouseClicked
        if (evt.getClickCount() == 2) {
            repaitMainGame();
        }
    }//GEN-LAST:event_pn_avatarMouseClicked

    public Graphics getGraphicsMain() {
        if (mainGraphics == null) {
            mainGraphics = main_panel.getGraphics();
        }
        return mainGraphics;
    }

    public void appentTextToChatBox(String mess) {
        chat_box.append(mess);
        chat_box.append(CommonDefine.BREAK_LINE);
        chat_box.setCaretPosition(chat_box.getDocument().getLength());
    }

    public void enablePlayGame() {
        if (host && !start_enable && !start) {
            //resetVariableToRestart();
            setStartEnable(true);
            drawPlayButton(getGraphicsMain(), false);
        }
    }

    public void enableHost() {
        host = true;
        btn_submit.setEnabled(true);
        tf_betcoin.setEditable(false);
    }

    public void countdown(int timecd, int timeMax) {
        if (timecd == 0) {
            setEnableTurn(false);
            clearTimeCounDown();
        } else {
            drawCountDownImg(timecd, timeMax, isEnableTurn());
        }
    }

    private void repaitMainGame() {
        repaintGame();
        if (start_enable) {
            drawPlayButton(getGraphicsMain(), false);
        }
        if (start) {
            drawPassButton(getGraphicsMain(), false);
            drawFightButton(getGraphicsMain(), false);
        }
    }

    public void executeAction(String data) {
        String[] strs = data.split(CommonDefine.SEPARATOR_KEY_VALUE);
        if (CommonMethod.isValidNumber(strs[1])) {
            int p_val = Integer.parseInt(strs[1].trim());
            List<Card> list = new ArrayList<>();
            if (strs[0].contains(CommonDefine.COMMA)) {
                for (String s : strs[0].split(CommonDefine.COMMA)) {
                    String elems[] = s.split("_");
                    if (CommonMethod.isValidNumber(elems[0]) && CommonMethod.isValidNumber(elems[1])) {
                        Card c = new Card(Integer.parseInt(elems[0].trim()), CardType.valueOf(Integer.parseInt(elems[1].trim())));
                        if (c.getType().getValue() != CardType.INVALID.getValue()) {
                            list.add(c);
                        }
                    }
                }
            }
            drawListCardFight(list, p_val);
        }
    }

    public void initTEST() {
        listOwnCard = new ArrayList<>();
        listPlayer = new ArrayList<>();
        listOwnCard.add(new Card(1, CardType.HEART));
        listOwnCard.add(new Card(2, CardType.SPADE));
        listOwnCard.add(new Card(3, CardType.DIAMOND));
        listOwnCard.add(new Card(4, CardType.HEART));
        listOwnCard.add(new Card(5, CardType.SPADE));
        listOwnCard.add(new Card(6, CardType.SPADE));
        listOwnCard.add(new Card(7, CardType.SPADE));
        listOwnCard.add(new Card(8, CardType.SPADE));
        listOwnCard.add(new Card(10, CardType.CLUB));
        //listOwnCard.add(new Card(11, CardType.SPADE));
        //listOwnCard.add(new Card(12, CardType.SPADE));
        listOwnCard.add(new Card(13, CardType.HEART));
        listOwnCard.add(new Card(9, CardType.SPADE));

        widthOfList = CARD_PX_SCALE * (listOwnCard.size() - 1) + CARD_P_WIDTH;
        xStartOfList = (BUTTON_X_START - widthOfList) / 2;
        yStartOfList = GAME_HEIGHT - CARD_P_HEIGHT + CARD_PX_SCALE;

        listPlayer.add(new Player(1, "player__0_0_0_1", listOwnCard.size(), 1000));
        listPlayer.add(new Player(2, "player_2", listOwnCard.size(), 5000));
        listPlayer.add(new Player(3, "player_3_3333333", listOwnCard.size(), 300000));
        listPlayer.add(new Player(4, "player_4", listOwnCard.size(), 2000));
        myValue = 2;
        drawPlayersInfo();

    }
    //<editor-fold defaultstate="collapsed" desc="Func">
    private static final int MAX_PLAYER = 4;
    private static final int GAME_HEIGHT = 600;
    private static final int GAME_WIDTH = 900;
    private static final int CARD_P_HEIGHT = 150;
    private static final int CARD_P_WIDTH = 120;
    private static final int CARD_F_HEIGHT = 100;
    private static final int CARD_F_WIDTH = 80;
    private static final int CARD_E_HEIGHT = 80;
    private static final int CARD_E_WIDTH = 64;
    private static final int PLAYER_SIZE = 40;

    private static final int CARD_PX_SCALE = CARD_P_WIDTH / 4;
    private static final int CARD_FX_SCALE = CARD_F_WIDTH / 4;
    private static final int CARD_EX_SCALE = CARD_E_WIDTH / 4;

    private static final int BUTTON_HEIGHT = 30;
    private static final int BUTTON_WIDTH = 50;
    private static final int BUTTON_X_START = 780;
    private static final int BUTTON_Y_START = 535;
    private static final int BUTTON_X_SCALE = 10;
    private static final int BUTTON_PLAY_WIDTH = 201;
    private static final int BUTTON_PLAY_HEIGHT = 48;

    private static final int IMG_COUNT_DOWN_X_START = 680;
    private static final int IMG_COUNT_DOWN_Y_START = 535;
    private static final int IMG_COUNT_DOWN_WIDTH = 50;
    private static final int IMG_COUNT_DOWN_HEIGHT = 28;

    private static final Color BACKGROUND_COLOR = new Color(102, 102, 102);
    private static final Color CARD_HIDE_COLOR = new Color(0, 0, 0, 127);
    private static final Color PLAYER_INFO_COLOR = new Color(40, 180, 99);

    private int LIMIT_CARD = 13;
    private static final int LIMIT_CARD_NUM_TLMN = 13;
    private static final int LIMIT_CARD_NUM_SL = 10;

    private List<Card> listOwnCard;
    private List<Player> listPlayer;

    ////////reset when next turn
    private List<Card> listPreviousFight = null;
    private int preValueList = 0;
    //////////////
    private int myValue;
    private int widthOfList;
    private int xStartOfList;
    private int yStartOfList;
    private int gameType;
    private int hostVal;
    private int stealWinVal;

    public void initListImage(Map<String, Image> listImage) {
        this.listImageCard = listImage;
    }

    public void initMyValue(int myValue) {
        this.myValue = myValue;
    }

    public void initLimitCardNum(int gameType) {
        setGameType(gameType);
        switch (gameType) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                LIMIT_CARD = LIMIT_CARD_NUM_TLMN;
                break;
            case CommonDefine.GAME_TYPE_SL_GAME:
                LIMIT_CARD = LIMIT_CARD_NUM_SL;
                break;
            default:
                break;
        }
    }

    public int getHostVal() {
        return hostVal;
    }

    public void setHostVal(int hostVal) {
        new Thread(() -> {
            try {
                Thread.sleep(500);
                if (this.hostVal != hostVal) {
                    Player prHost = getPlayerByValue(this.hostVal);
                    this.hostVal = hostVal;
                    Player crHost = getPlayerByValue(this.hostVal);
                    if (prHost != null) {
                        drawEnemyInfo(prHost);
                    }
                    if (crHost != null) {
                        drawEnemyInfo(crHost);
                    }
                }
            } catch (InterruptedException ex) {
                Logger.getLogger(FrameCard.class.getName()).log(Level.SEVERE, null, ex);
            }
        }).start();
    }

    public int getGameType() {
        return gameType;
    }

    private void setGameType(int gameType) {
        this.gameType = gameType;
    }

    public void repaintGame() {
        drawPlayersInfo();
        drawPreviousListCard();
    }

    public void initListOwnCardDeck(String data) {
        listOwnCard = new ArrayList<>();
        String[] cardDatas = data.split(CommonDefine.COMMA);
        for (String strCard : cardDatas) {
            String[] elements = strCard.split("_");
            if (elements.length == 2) {
                int num = Integer.parseInt(elements[0].trim());
                CardType type = CardType.valueOf(Integer.parseInt(elements[1].trim()));
                if (type != CardType.INVALID) {
                    Card card = new Card(num, type);
                    listOwnCard.add(card);
                }
            }
        }
        if (LIMIT_CARD != listOwnCard.size()) {
            System.out.println("Card is missing! list card size: " + listOwnCard.size());
        }
        for (Player p : listPlayer) {
            p.setCardNums(LIMIT_CARD);
        }
        CardFunc.sortCardByNumAndType(listOwnCard);
        widthOfList = CARD_PX_SCALE * (listOwnCard.size() - 1) + CARD_P_WIDTH;
        xStartOfList = (BUTTON_X_START - widthOfList) / 2;
        yStartOfList = GAME_HEIGHT - CARD_P_HEIGHT + CARD_PX_SCALE;
        drawPlayersInfo();
    }

    public void initPlayer(List<Player> listPlayer) {
        this.listPlayer = listPlayer;
        drawPlayersInfo();
    }

    public void addPlayer(Player player) {
        listPlayer.add(player);
        drawEnemyInfo(player);
        drawEnemyListCard(player);
    }

    public void removePlayer(int val) {
        Graphics g = getGraphicsMain();
        Font f = new Font("Tahoma", Font.BOLD, 13);
        int w_clear_text = g.getFontMetrics(f).stringWidth("abcdefhgabcdefgh");
        int w_clear_info = w_clear_text + PLAYER_SIZE + PLAYER_SIZE / 4;
        int x_clear_info;
        int y_img, y, remove_x;
        if (isNextValue(val, myValue)) {
            x_clear_info = GAME_WIDTH - w_clear_info;
            y_img = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 - PLAYER_SIZE / 2);
            remove_x = (GAME_WIDTH - (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH));
            y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
        } else if (isPreviousValue(val, myValue)) {
            x_clear_info = 0;
            y_img = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 - PLAYER_SIZE / 2);
            y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
            remove_x = 0;
        } else {
            x_clear_info = (GAME_WIDTH - w_clear_info) / 2;
            y_img = 0;
            y = PLAYER_SIZE;
            remove_x = (GAME_WIDTH - (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH)) / 2;
        }
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(x_clear_info, y_img, w_clear_info, PLAYER_SIZE);
        g.fillRect(remove_x, y, (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH), CARD_E_HEIGHT);
        Player p = getPlayerByValue(val);
        if (p != null) {
            listPlayer.remove(p);
        }
        if (listPlayer.size() == 1) {
            waittingState();
        }
    }

    public void waittingState() {
        Graphics g = getGraphicsMain();
        setStart(false);
        setEnableTurn(false);
        setHost(true);
        setStartEnable(false);
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    }

    public void drawPlayersInfo() {
        if (listPlayer == null || listPlayer.isEmpty()) {
            return;
        }
        for (Player p : listPlayer) {
            if (p.getValue() != myValue) {
                drawEnemyInfo(p);
                drawEnemyListCard(p);
            } else {
                drawOwnInfomation(p);
                drawListOwnCard();
            }
        }
    }

    public void drawOwnInfomation(Player p) {
        Image img = listImageCard.get("player");
        if (isHost()) {
            img = listImageCard.get("host");
        }
        pn_avatar.getGraphics().drawImage(img, 0, 0, pn_avatar.getWidth(), pn_avatar.getHeight(), null);
        lb_name.setText("Username: " + p.getName());
        lb_coin.setText("Coin: " + p.getCoin());
    }

    public void drawEnemyInfo(Player p) {
        Graphics g = getGraphicsMain();
        Image img = listImageCard.get("player");
        if (p.getValue() == hostVal) {
            img = listImageCard.get("host");
        }
        Font f = new Font("Tahoma", Font.BOLD, 13);
        int w_clear_text = g.getFontMetrics(f).stringWidth("abcdefhgabcdefgh");
        int w_clear_info = w_clear_text + PLAYER_SIZE + PLAYER_SIZE / 4;
        int x_clear_info;
        int n_w = g.getFontMetrics(f).stringWidth(p.getName());
        int c_w = g.getFontMetrics(f).stringWidth(String.valueOf(p.getCoin()));
        int str_w = n_w > c_w ? n_w : c_w;
        int str_h = g.getFontMetrics(f).getHeight();
        int x_img, y_img, x_name, y_name;
        if (isNextValue(p.getValue(), myValue)) {
            x_img = (GAME_WIDTH - PLAYER_SIZE - PLAYER_SIZE / 4 - str_w);
            x_clear_info = GAME_WIDTH - w_clear_info;
            y_img = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 - PLAYER_SIZE / 2);
        } else if (isPreviousValue(p.getValue(), myValue)) {
            x_img = 0;
            x_clear_info = 0;
            y_img = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 - PLAYER_SIZE / 2);
        } else {
            x_img = (GAME_WIDTH - (PLAYER_SIZE + PLAYER_SIZE / 4 + str_w)) / 2;
            x_clear_info = (GAME_WIDTH - w_clear_info) / 2;
            y_img = 0;
        }
        y_name = y_img + (PLAYER_SIZE - str_h * 2 - str_h / 4) / 2;
        x_name = x_img + PLAYER_SIZE + PLAYER_SIZE / 4;
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(x_clear_info, y_img, w_clear_info, PLAYER_SIZE);
        g.drawImage(img, x_img, y_img, PLAYER_SIZE, PLAYER_SIZE, null);
        g.setFont(f);
        g.setColor(PLAYER_INFO_COLOR);
        g.drawString(p.getName(), x_name, y_name + str_h);
        g.drawString(String.valueOf(p.getCoin()), x_name, y_name + 2 * str_h);

    }

    public void drawEnemyListCard(Player p) {
        Graphics g = getGraphicsMain();
        Image img = listImageCard.get("card_back");
        int x, y, remove_x;
        if (isNextValue(p.getValue(), myValue)) {
            x = (GAME_WIDTH - (CARD_EX_SCALE * (p.getCardNums() - 1) + CARD_E_WIDTH));
            y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
            remove_x = (GAME_WIDTH - (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH));
        } else if (isPreviousValue(p.getValue(), myValue)) {
            x = 0;
            y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
            remove_x = 0;
        } else {
            x = (GAME_WIDTH - (CARD_EX_SCALE * (p.getCardNums() - 1) + CARD_E_WIDTH)) / 2;
            y = PLAYER_SIZE;
            remove_x = (GAME_WIDTH - (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH)) / 2;
        }
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(remove_x, y, (CARD_EX_SCALE * (LIMIT_CARD - 1) + CARD_E_WIDTH), CARD_E_HEIGHT);
        for (int i = 0; i < p.getCardNums(); i++) {
            g.drawImage(img, x + CARD_EX_SCALE * i, y, CARD_E_WIDTH, CARD_E_HEIGHT, null);
        }
    }

    public void updatePlayer(int val, String name, int coinAdd, int cardNumAdd) {
        for (Player p : listPlayer) {
            if (p.getValue() == val) {
                if (name != null) {
                    p.setName(name);
                    ///
                }
                if (cardNumAdd > 0) {
                    p.setCardNums(p.getCardNums() + cardNumAdd);
                    ///
                }
                if (coinAdd != 0) {
                    p.setCoin(p.getCoin() + coinAdd);
                    drawPlayerCoinUpdate(val, coinAdd);
                    if (coinAdd > 0 && stealWinVal != 0) {
                        drawTextStealWin(val, stealWinVal);
                    }
                }
                if (val == myValue) {
                    ClientFrame.getClientFrame().addCoin(coinAdd);
                    drawOwnInfomation(p);
                } else {
                    drawEnemyInfo(p);
                }
                break;
            }
        }
    }

    public void drawTextStealWin(int val, int stVal) {
        Image img = listImageCard.get("win_" + String.valueOf(stVal));
        int x, y;
        int img_w = img.getWidth(null);
        int img_h = img.getHeight(null);
        int scale = 20;
        if (val != myValue) {
            if (isNextValue(val, myValue)) {
                x = GAME_WIDTH - img_w - scale;
                y = GAME_HEIGHT / 2 + PLAYER_SIZE / 2 - img_h / 2;
            } else if (isPreviousValue(val, myValue)) {
                x = scale;
                y = GAME_HEIGHT / 2 + PLAYER_SIZE / 2 - img_h / 2;
            } else {
                x = GAME_WIDTH / 2 - img_w / 2;
                y = PLAYER_SIZE + CARD_E_HEIGHT / 2 - img_h / 2;
            }
        } else {
            x = GAME_WIDTH / 2 - img_w;
            y = GAME_HEIGHT - CARD_P_HEIGHT + CARD_PX_SCALE + CARD_P_HEIGHT / 2 - img_h / 2;
        }
        Graphics g = getGraphicsMain();
        g.drawImage(img, x, y, img_w, img_h, null);
    }

    public void drawPlayerCoinUpdate(int val, int coinAdd) {
        if (coinAdd == 0) {
            return;
        }
        Graphics g = getGraphicsMain();
        Font f = new Font("Tahoma", Font.BOLD, 13);
        String strCoinUpdate = coinAdd < 0 ? String.valueOf("- " + Math.abs(coinAdd)) : String.valueOf("+ " + Math.abs(coinAdd));
        int cw = g.getFontMetrics(f).stringWidth(String.valueOf(strCoinUpdate));
        int ch = g.getFontMetrics(f).getHeight();
        int x;
        int y;
        int scale = 10;
        if (val != myValue) {
            if (isNextValue(val, myValue)) {
                x = GAME_WIDTH - cw - scale;
                y = (GAME_HEIGHT / 2 + CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2) + scale + ch;
            } else if (isPreviousValue(val, myValue)) {
                x = scale;
                y = (GAME_HEIGHT / 2 + CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2) + scale + ch;
            } else {
                x = GAME_WIDTH / 2 - cw / 2;
                y = PLAYER_SIZE + CARD_E_HEIGHT + scale + ch;
            }
        } else {
            x = GAME_WIDTH / 2 - cw / 2;
            y = GAME_HEIGHT - CARD_P_HEIGHT - scale;
        }
        if (coinAdd > 0) {
            g.setColor(new Color(0, 255, 255));
        } else {
            g.setColor(new Color(255, 0, 0));
        }
        g.setFont(f);
        g.drawString(strCoinUpdate, x, y);
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                g.setColor(BACKGROUND_COLOR);
                g.fillRect(x - scale / 2, y - scale / 2 - ch, cw + scale, ch + scale);
                if (val == myValue) {
                    if (ClientFrame.getClientFrame().getTotalCoint() <= 0) {
                        this.formWindowClosing(null);
                    }
                }
            } catch (InterruptedException ex) {
                Logger.getLogger(FrameCard.class.getName()).log(Level.SEVERE, null, ex);
            }
        }).start();
    }

    public void drawEnemyListCardEndGame(Map<Integer, List<Card>> mapListCard) {
        Graphics g = getGraphicsMain();
        for (Entry<Integer, List<Card>> entry : mapListCard.entrySet()) {
            List<Card> list = entry.getValue();
            if (list.isEmpty()) {
                continue;
            }
            int size = list.size();
            int val = entry.getKey();
            int x, y, remove_x;
            if (val == myValue) {
                continue;
            }
            int ex_scale = CARD_EX_SCALE;
            if (isNextValue(val, myValue)) {
                x = (GAME_WIDTH - (ex_scale * (size - 1) + CARD_E_WIDTH));
                y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
                remove_x = (GAME_WIDTH - (ex_scale * (LIMIT_CARD - 1) + CARD_E_WIDTH));
            } else if (isPreviousValue(val, myValue)) {
                x = 0;
                y = (GAME_HEIGHT / 2 - CARD_E_HEIGHT / 2 + PLAYER_SIZE / 2);
                remove_x = 0;
            } else {
                x = (GAME_WIDTH - (ex_scale * (size - 1) + CARD_E_WIDTH)) / 2;
                y = PLAYER_SIZE;
                remove_x = (GAME_WIDTH - (ex_scale * (LIMIT_CARD - 1) + CARD_E_WIDTH)) / 2;
            }
            g.setColor(BACKGROUND_COLOR);
            g.fillRect(remove_x, y, (ex_scale * (LIMIT_CARD - 1) + CARD_E_WIDTH), CARD_E_HEIGHT);
            for (int i = 0; i < size; i++) {
                drawCardImage(list.get(i), x + ex_scale * i, y, CARD_E_WIDTH, CARD_E_HEIGHT);
            }
        }
    }

    public boolean onClickPass() {
        if (listPreviousFight == null) {
            return false;
        }
        ClientFrame.getClientFrame().sendMessage(CommonDefine.CARD_GAME_ACTION_PASS);
        return true;
    }

    public boolean onClickFight() {
        List<Card> list = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (Card card : listOwnCard) {
            if (card.isSelected()) {
                list.add(card);
                sb.append(card.toString()).append(CommonDefine.COMMA);
            }
        }
        if (CardFunc.checkListCardFight(listPreviousFight, list, getGameType())) {
            ClientFrame.getClientFrame().sendMessage(CommonDefine.CARD_GAME_ACTION_FIGHT + sb.toString());
            return true;
        }
        return false;
    }

    public void selectCard(int x, int y) {
        if (listOwnCard == null || listOwnCard.isEmpty()) {
            return;
        }
        for (int i = 0; i < listOwnCard.size(); i++) {
            int s_w;
            int s_h = 0;
            if (listOwnCard.get(i).isSelected()) {
                s_h = CARD_PX_SCALE;
            }
            if (i != listOwnCard.size() - 1) {
                s_w = CARD_PX_SCALE;
            } else {
                s_w = CARD_P_WIDTH;
            }
            if (x > xStartOfList + CARD_PX_SCALE * i && x < xStartOfList + s_w + CARD_PX_SCALE * i && y > yStartOfList - s_h && y < GAME_HEIGHT) {
                listOwnCard.get(i).setSelected(!listOwnCard.get(i).isSelected());
                drawListOwnCard();
                break;
            }
        }
    }

    public void drawListOwnCard() {
        if (listOwnCard == null) {
            return;
        }
        Graphics g = getGraphicsMain();
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(xStartOfList, GAME_HEIGHT - CARD_P_HEIGHT - CARD_PX_SCALE, widthOfList, CARD_P_HEIGHT + CARD_PX_SCALE);
        for (int i = 0; i < listOwnCard.size(); i++) {
            drawOwnCardImage(listOwnCard.get(i), xStartOfList + i * CARD_PX_SCALE, yStartOfList);
        }
    }

    private Player getPlayerByValue(int val) {
        for (Player p : listPlayer) {
            if (p.getValue() == val) {
                return p;
            }
        }
        return null;
    }

    public void drawListCardFight(List<Card> list, int p_val) {
        if (list.isEmpty()) {
            return;
        }
        if (p_val == myValue) {
            for (Card rCard : list) {
                listOwnCard.remove(rCard);
            }
            drawListOwnCard();
        } else {
            for (Player p : listPlayer) {
                if (p.getValue() == p_val) {
                    p.setCardNums(p.getCardNums() - list.size());
                    break;
                }
            }
            Player p = getPlayerByValue(p_val);
            if (p != null) {
                drawEnemyListCard(p);
            }
        }
        Graphics g = getGraphicsMain();
        int start_x = (GAME_WIDTH - (CARD_FX_SCALE * (list.size() - 1) + CARD_F_WIDTH)) / 2;
        int start_y = (GAME_HEIGHT - CARD_F_HEIGHT) / 2;
        CardFunc.sortCardByNumAndType(list);
        if (listPreviousFight != null && !listPreviousFight.isEmpty()) {
            int x = (GAME_WIDTH - (CARD_FX_SCALE * (listPreviousFight.size() - 1) + CARD_F_WIDTH)) / 2;
            int y = (GAME_HEIGHT - CARD_F_HEIGHT) / 2;
            if (preValueList != 0) {
                if (preValueList == myValue) {
                    y += CARD_FX_SCALE;
                } else {
                    if (isNextValue(preValueList, myValue)) {
                        x += CARD_FX_SCALE;
                    } else if (isPreviousValue(preValueList, myValue)) {
                        x -= CARD_FX_SCALE;
                    } else {
                        y -= CARD_FX_SCALE;
                    }
                }
                g.setColor(CARD_HIDE_COLOR);
                g.fillRect(x, y, (CARD_FX_SCALE * (listPreviousFight.size() - 1) + CARD_F_WIDTH), CARD_F_HEIGHT);
            }
        }
        listPreviousFight = list;
        preValueList = p_val;
        if (p_val == myValue) {
            start_y += CARD_FX_SCALE;
        } else {
            if (isNextValue(p_val, myValue)) {
                start_x += CARD_FX_SCALE;
            } else if (isPreviousValue(p_val, myValue)) {
                start_x -= CARD_FX_SCALE;
            } else {
                start_y -= CARD_FX_SCALE;
            }
        }
        for (int i = 0; i < list.size(); i++) {
            drawCardImage(list.get(i), start_x + i * CARD_FX_SCALE, start_y, CARD_F_WIDTH, CARD_F_HEIGHT);
        }
    }

    private void drawPreviousListCard() {
        clearRound();
        if (listPreviousFight != null && !listPreviousFight.isEmpty()) {
            int x = (GAME_WIDTH - (CARD_FX_SCALE * (listPreviousFight.size() - 1) + CARD_F_WIDTH)) / 2;
            int y = (GAME_HEIGHT - CARD_F_HEIGHT) / 2;
            for (int i = 0; i < listPreviousFight.size(); i++) {
                drawCardImage(listPreviousFight.get(i), x + i * CARD_FX_SCALE, y, CARD_F_WIDTH, CARD_F_HEIGHT);
            }
        }
    }

    private void drawCardImage(Card card, int x, int y, int w, int h) {
        Graphics g = getGraphicsMain();
        Image img = listImageCard.get(card.getRealNum() + "_" + card.getType().getValue());
        g.drawImage(img, x, y, w, h, null);
    }

    private void drawOwnCardImage(Card card, int x, int y) {
        Graphics g = getGraphicsMain();
        Image img = listImageCard.get(card.getRealNum() + "_" + card.getType().getValue());
        if (card.isSelected()) {
            g.drawImage(img, x, y - CARD_PX_SCALE, CARD_P_WIDTH, CARD_P_HEIGHT, null);
        } else {
            g.drawImage(img, x, y, CARD_P_WIDTH, CARD_P_HEIGHT, null);
        }
    }

    public void clearRound() {
        Graphics g = getGraphicsMain();
        listPreviousFight = null;
        g.setColor(BACKGROUND_COLOR);
        int w = (CARD_FX_SCALE * (LIMIT_CARD - 1) + CARD_F_WIDTH + 2 * CARD_FX_SCALE);
        int h = (CARD_F_HEIGHT + 2 * CARD_FX_SCALE);
        g.fillRect((GAME_WIDTH - w) / 2, (GAME_HEIGHT - h) / 2, w, h);
    }

    public void endGame(String strVal) {
        switch (getGameType()) {
            case CommonDefine.GAME_TYPE_TLMN_GAME:
                resetVariableToRestart();
                stealWinVal = CommonMethod.isValidNumber(strVal) ? Integer.parseInt(strVal.trim()) : 0;
            case CommonDefine.GAME_TYPE_SL_GAME:

            default:
                break;
        }
    }

    private void resetVariableToRestart() {
        preValueList = 0;
        listPreviousFight = null;
        setStart(false);
        setStartEnable(false);
        setEnableTurn(false);
    }

    public void clearTimeCounDown() {
        Graphics g = getGraphicsMain();
        g.setColor(BACKGROUND_COLOR);
        g.fillRect(IMG_COUNT_DOWN_X_START, IMG_COUNT_DOWN_Y_START, IMG_COUNT_DOWN_WIDTH, IMG_COUNT_DOWN_HEIGHT);
    }

    public void drawCountDownImg(int timecd, int maxTime, boolean isTurn) {
        Graphics g = getGraphicsMain();
        if (isTurn) {
            clearTimeCounDown();
            Image img = listImageCard.get("count_down_" + timecd);
            int w = img.getWidth(null);
            g.drawImage(img, (IMG_COUNT_DOWN_X_START + (IMG_COUNT_DOWN_WIDTH - w) / 2), IMG_COUNT_DOWN_Y_START, w, IMG_COUNT_DOWN_HEIGHT, null);
        } else {

        }
    }

    public void drawPlayButton(Graphics g, boolean isHover) {
        clearRound();
        Image img = listImageCard.get("play_game");
        if (isHover) {
            img = listImageCard.get("play_game_hover");
        }
        g.drawImage(img, (GAME_WIDTH - BUTTON_PLAY_WIDTH) / 2, (GAME_HEIGHT - BUTTON_PLAY_HEIGHT) / 2, BUTTON_PLAY_WIDTH, BUTTON_PLAY_HEIGHT, null);
    }

    public void drawPlayButtonPress(Graphics g) {
        clearRound();
        Image img = listImageCard.get("play_game_press");
        int w = 176;
        int h = 44;
        g.drawImage(img, (GAME_WIDTH - w) / 2, (GAME_HEIGHT - h) / 2, w, h, null);
    }

    public void drawFightButton(Graphics g, boolean isHover) {
        String text = "Đánh";
        Font f = new Font("Tahoma", Font.BOLD, 12);
        int txt_w = g.getFontMetrics(f).stringWidth(text);
        int txt_h = g.getFontMetrics(f).getHeight();
        if (isHover) {
            g.setColor(new Color(39, 174, 96));//hover color
            g.fill3DRect(BUTTON_X_START, BUTTON_Y_START, BUTTON_WIDTH, BUTTON_HEIGHT, true);
            g.setFont(f);
            g.setColor(new Color(230, 126, 34));
            g.drawString(text, BUTTON_X_START + (BUTTON_WIDTH - txt_w) / 2, BUTTON_Y_START + BUTTON_HEIGHT / 2 + txt_h / 3);
        } else {
            g.setColor(new Color(230, 126, 34));//color
            g.fill3DRect(BUTTON_X_START, BUTTON_Y_START, BUTTON_WIDTH, BUTTON_HEIGHT, true);
            g.setFont(f);
            g.setColor(new Color(244, 246, 247));
            g.drawString(text, BUTTON_X_START + (BUTTON_WIDTH - txt_w) / 2, BUTTON_Y_START + BUTTON_HEIGHT / 2 + txt_h / 3);
        }
    }

    public void drawPassButton(Graphics g, boolean isHover) {
        String text = "Bỏ qua";
        Font f = new Font("Tahoma", Font.BOLD, 12);
        int txt_w = g.getFontMetrics(f).stringWidth(text);
        int txt_h = g.getFontMetrics(f).getHeight();
        if (isHover) {
            g.setColor(new Color(224, 224, 224));
            g.fill3DRect(BUTTON_X_START + BUTTON_WIDTH + BUTTON_X_SCALE, BUTTON_Y_START, BUTTON_WIDTH, BUTTON_HEIGHT, true);
            g.setFont(f);
            g.setColor(new Color(75, 75, 75));
            g.drawString(text, BUTTON_X_START + BUTTON_WIDTH + BUTTON_X_SCALE + (BUTTON_WIDTH - txt_w) / 2, BUTTON_Y_START + BUTTON_HEIGHT / 2 + txt_h / 3);
        } else {
            g.setColor(new Color(100, 100, 100));
            g.fill3DRect(BUTTON_X_START + BUTTON_WIDTH + BUTTON_X_SCALE, BUTTON_Y_START, BUTTON_WIDTH, BUTTON_HEIGHT, true);
            g.setFont(f);
            g.setColor(new Color(240, 240, 240));
            g.drawString(text, BUTTON_X_START + BUTTON_WIDTH + BUTTON_X_SCALE + (BUTTON_WIDTH - txt_w) / 2, BUTTON_Y_START + BUTTON_HEIGHT / 2 + txt_h / 3);
        }
    }

    private boolean isNextValue(int e_val, int p_val) {
        return (e_val == p_val + 1 || (p_val == 4 && e_val == 1));
    }

    private boolean isPreviousValue(int e_val, int p_val) {
        return (e_val == p_val - 1 || (e_val == 4 && p_val == 1));
    }

    public boolean isPlayGameHover(int x, int y) {
        return (x > (GAME_WIDTH - BUTTON_PLAY_WIDTH) / 2 && x < (GAME_WIDTH + BUTTON_PLAY_WIDTH) / 2 && y > (GAME_HEIGHT - BUTTON_PLAY_HEIGHT) / 2 && y < (GAME_HEIGHT + BUTTON_PLAY_HEIGHT) / 2);
    }

    public boolean isListCardHover(int x, int y) {
        return (x > xStartOfList && x < xStartOfList + widthOfList && y > yStartOfList - CARD_PX_SCALE && y < GAME_HEIGHT);
    }

    public boolean isButtonFightHover(int x, int y) {
        return (x > BUTTON_X_START && x < BUTTON_X_START + BUTTON_WIDTH && y > BUTTON_Y_START && y < BUTTON_Y_START + BUTTON_HEIGHT);
    }

    public boolean isButtonPassHover(int x, int y) {
        return (x > BUTTON_X_START + BUTTON_WIDTH + BUTTON_X_SCALE && x < BUTTON_X_START + 2 * BUTTON_WIDTH + BUTTON_X_SCALE && y > BUTTON_Y_START && y < BUTTON_Y_START + BUTTON_HEIGHT);
    }
    //</editor-fold>

//    public static void main(String[] args) {
//        FrameCard fc = new FrameCard(null);
//        fc.setVisible(true);
//        fc.test();
//    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btn_submit;
    private javax.swing.JTextArea chat_box;
    private javax.swing.JPanel ctop_1;
    private javax.swing.JPanel ctop_2;
    private javax.swing.JPanel ctop_3;
    private javax.swing.JPanel ctop_4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel lb_bet;
    private javax.swing.JLabel lb_coin;
    private javax.swing.JLabel lb_name;
    private javax.swing.JPanel left_panel;
    private javax.swing.JPanel main_panel;
    private javax.swing.JPanel pn_avatar;
    private javax.swing.JTextField tf_betcoin;
    private javax.swing.JTextField tf_mess;
    private javax.swing.JPanel top_panel;
    // End of variables declaration//GEN-END:variables
}
